%! Author = Martin Vandenbussche

\section{The intial situation (find a better title)}\label{sec:ch3-0}
Extract from Jean-Pacifique's thesis :
"One of the key elements of this project is that compatibility has to be maintained with the existing Mozart system, for the official release of Mozart2.
The idea of writing a new compiler has thus quickly been set aside, as it would drastically increase the time and complexity requirements of the project."\cite{jpthesis}

Instead, last year's thesis brought forward (???) the idea of writing a syntax parser, that would serve as a compatibility layer between the so-called "NewOz" syntax, and the existing Oz syntax supported by the current version of Mozart.
NewOz code will be translated to the directly equivalent Oz code, and then fed to the existing Oz compiler, \texttt{ozc}.
Some readers might interject that lies closer to the definition of a compiler than a parser;
for this reason, I think it is important to take the time and explicit the definition we give to each term in the context of this work.
Wikipedia defines parsing as "the formal analysis by a computer of a sentence or other string of words into its constituents, resulting in a parse tree showing their syntactic relation to each other [\ldots]".\footnote{Cite correctly : https://en.wikipedia.org/wiki/Parsing, consulted on 13/05-11:54}
A compiler, on the other hand, is described as "a computer program that translates computer code written in one programming language (the source language) into another language (the target language)."\footnote{Cite correctly : https://en.wikipedia.org/wiki/Compiler, consulted on 13/05-12:06}
In my opinion, the program created by M. Mbonyincungu doesn't match any of those two definitions [de maniÃ¨re satisfaisante], as we will discuss later;
I think it lies somewhere in between those two definitions.
But to stay consistent with the vocabulary used in lest year's thesis and avoid confusion, we will refer to it as "the Parser".

M. Mbonyincungu's Parser makes use of Scala's Parsing Combinators library\footnote{cite correctly : https://www.scala-lang.org/api/2.12.3/scala-parser-combinators/scala/util/parsing/combinator/Parsers.html}, which provides a syntax to match regular expressions and describe the relationship between them.
The matched expressions are then translated to \texttt{Oz} code, with a great emphasis being put on maintaining the code's visual format.\footnote{See sections 3.2.3 and 3.3.1 of~\cite{jpthesis}}
This is important because the Parser was designed as a decorator to the Mozart compiler (which means that having code roughly at the same place will make debugging programs a lot easier), but also because it can prove useful in a teaching context in the future, when comparing the two syntax's side by side.

Three approaches
This "parser approach" has been preferred over a "full" compiler implementation for multiple reasons, which we will comment on below :
\begin{itemize}
    \item Because of its lower technical complexity, it took less time to design;
    \item its reliance
is easier to implement, relies on more modern technologies than the existing Mozart compiler, and will allow for more flexibility down the line because of the nature of the underlying Scala code of the Parser.
We should however keep in mind the major limitation that this approach brings : error messages generated by the Mozart compiler will be way harder to interpret by the end-user.
One of the goals of the project being that this Parser-to-compiler behavior stays transparent to the programmer, we should keep in mind that future Oz learners will know nothing of the current Oz syntax.
As such, the compiler output will probably be obscure to them, and it is probably a good idea to try to alleviate this confusion as much as possible.\newline

IMPLEMENTATION - PAN TECHNIQUE/PRATIQUE

\section{The need for something else}\label{sec:ch3-1}
Why did we feel like we needed to make a full compiler, and why we didn't go all the way to the machine language

\section{A quick introduction to compilers}\label{sec:ch3-2}
How do compilers work in general ?
Try to keep it not TOO technical and long.
Lexer - Parser/syntax analysis - Semantic analysis - (optimizer) - code generator
\section{Nozc dissected}\label{sec:ch3-3}
General description of the inner workings of the compiler.
Do not go in ridiculous details, as the code is well documented and available.
Use an example and show its evolution when going through the compiler.

\section{Technologies used}\label{sec:ch3-4}
Why Java (pros and cons) (mention Java here for 1st time -> forces me to be generic in previous section). picocli, JavaCC.\newline
Try to make it short

\section{Advantages of this approach}\label{sec:ch3-5}
Persuade the reader that it is a great platform to reuse and build upon.
How useful it can be for future works on the syntax

\section{Limitations of this approach}\label{sec:ch3-6}
Let's keep it real, it is not perfect either\ldots

\section{What's next for nozc ?}\label{sec:ch3-7}